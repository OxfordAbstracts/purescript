{-# LANGUAGE PackageImports #-}

module Language.PureScript.Lsp.CacheCopy where

import Codec.Serialise (deserialise, serialise)
import Control.Lens ((^.))
import Data.Aeson (encode)
import Data.List qualified as List
import Data.Text qualified as T
import Database.SQLite.Simple
import Language.PureScript qualified as P
import Language.PureScript.CST qualified as CST
import Language.PureScript.Externs (ExternsFile (efModuleName))
import Language.PureScript.Ide.Error (IdeError (RebuildError))
import Language.PureScript.Ide.Externs (convertExterns, readExternFile)
import Language.PureScript.Ide.State (convertDeclaration', resolveDataConstructorsForModule, resolveDocumentationForModule)
import Language.PureScript.Ide.Types (Annotation (_annDocumentation, _annExportedFrom, _annLocation, _annTypeAnnotation), IdeDeclaration (..), IdeDeclarationAnn (IdeDeclarationAnn, _idaAnnotation, _idaDeclaration), IdeNamespace (IdeNSModule, IdeNSType, IdeNSValue), ideDtorType, ideSynonymKind, ideTCKind, ideTypeKind, ideTypeOpKind, ideValueOpType, ideValueType)
import Language.PureScript.Ide.Util (ideReadFile)
import Language.PureScript.Lsp.DB qualified as DB
import Language.PureScript.Lsp.Types (LspConfig (..), LspEnvironment (lspConfig))
import Protolude
import System.FilePath ((</>))
import System.FilePath.Glob (glob)
import "monad-logger" Control.Monad.Logger (MonadLogger)

initCache ::
  (MonadIO m, MonadReader LspEnvironment m) =>
  m ()
initCache = do
  DB.execute_ $ Query "CREATE TABLE IF NOT EXISTS externs (name TEXT PRIMARY KEY, path TEXT, version TEXT, externs BLOB)"
  DB.execute_ $ Query "CREATE TABLE IF NOT EXISTS ident_source_spans (ident TEXT, start_col INTEGER, start_line INTEGER, end_col INTEGER, end_line INTEGER, name_space BLOB)"
  DB.execute_ $ Query "CREATE TABLE IF NOT EXISTS ef_imports (module_name TEXT, import_name TEXT, import_type BLOB, imported_as TEXT)"
  DB.execute_ $ Query "CREATE TABLE IF NOT EXISTS declarations (module_name TEXT, declaration BLOB, ann_start_col INTEGER, ann_start_line INTEGER, ann_end_col INTEGER, ann_end_line INTEGER, ann_exported_from TEXT, ann_type_annotation BLOB, ann_documentation BLOB, decl_start_col INTEGER, decl_start_line INTEGER, decl_end_col INTEGER, decl_end_line INTEGER, decl_comments TEXT, ann BLOB, decl BLOB)"


loadCache ::
  ( MonadIO m,
    MonadLogger m,
    MonadError IdeError m,
    MonadReader LspEnvironment m
  ) =>
  m [(FilePath, [CST.ParserWarning])]
loadCache = do
  globs <- asks (confGlobs . lspConfig)
  files <- liftIO $ concat <$> traverse glob globs
  traverse rebuildFile files

rebuildFile ::
  ( MonadIO m,
    MonadLogger m,
    MonadError IdeError m,
    MonadReader LspEnvironment m
  ) =>
  FilePath ->
  m (FilePath, [CST.ParserWarning])
rebuildFile srcPath = do
  outputDir <- asks (confOutputPath . lspConfig)
  (fp, input) <-
    case List.stripPrefix "data:" srcPath of
      Just source -> pure ("", T.pack source)
      _ -> ideReadFile srcPath -- todo replace with VFS
  (pwarnings, module') <- case sequence $ CST.parseFromFile fp input of
    Left parseError ->
      throwError $ RebuildError [(fp, input)] $ CST.toMultipleErrors fp parseError
    Right m -> pure m
  let externsPath = outputDir </> T.unpack (P.runModuleName $ P.getModuleName module') </> P.externsFileName
  externs <- readExternFile externsPath
  let (moduleDeclarations, _) = convertExterns externs
  decls <-
    moduleDeclarations
      & resolveDataConstructorsForModule
      & resolveLocations
      <&> resolveDocumentationForModule module'
  -- & resolveInstances externs
  -- & resolveOperatorsForModule
  -- & resolveReexports reexportRefs

  insertExtern srcPath externsPath externs decls
  pure (srcPath, pwarnings)

insertExtern ::
  (MonadIO m, MonadReader LspEnvironment m) =>
  FilePath ->
  FilePath ->
  ExternsFile ->
  [IdeDeclarationAnn] ->
  m ()
insertExtern srcPath externsPath extern annotatedDecls = do
  DB.executeNamed
    (Query "INSERT INTO externs (name, path) VALUES (:path, :name)")
    [ ":src_path" := srcPath,
      ":externs_path" := externsPath,
      ":ef_version" := P.efVersion extern,
      ":externs" := serialise extern,
      ":name" := P.runModuleName name
    ]

  forM_ (P.efImports extern) $ insertEfImport name
  forM_ annotatedDecls $ insertDeclaration name
  where
    name = efModuleName extern

insertEfImport :: (MonadIO m, MonadReader LspEnvironment m) => P.ModuleName -> P.ExternsImport -> m ()
insertEfImport moduleName' ei = do
  DB.executeNamed
    (Query "INSERT INTO ef_imports (module_name, import_name) VALUES (:module_name, :import_name)")
    [ ":module_name" := P.runModuleName moduleName',
      ":imported_module_name" := P.runModuleName (P.eiModule ei),
      ":import_type" := serialise (P.eiImportType ei),
      ":imported_as" := fmap P.runModuleName (P.eiImportedAs ei)
    ]

insertDeclaration :: (MonadIO m, MonadReader LspEnvironment m) => P.ModuleName -> IdeDeclarationAnn -> m ()
insertDeclaration moduleName' declAnn = do
  DB.executeNamed
    (Query "INSERT INTO declarations (module_name, declaration) VALUES (:module_name, :declaration)")
    [ ":module_name" := P.runModuleName moduleName',
      ":ann_start_col" := map (P.sourcePosColumn . P.spanStart) annLocation,
      ":ann_start_line" := map (P.sourcePosLine . P.spanStart) annLocation,
      ":ann_end_col" := map (P.sourcePosColumn . P.spanEnd) annLocation,
      ":ann_end_line" := map (P.sourcePosLine . P.spanEnd) annLocation,
      ":ann_exported_from" := map P.runModuleName (_annExportedFrom ann),
      ":ann_type_annotation" := serialise (_annTypeAnnotation ann),
      ":ann_documentation" := serialise (_annDocumentation ann),
      ":decl_start_col" := (P.sourcePosColumn . P.spanStart) declLocation,
      ":decl_start_line" := (P.sourcePosLine . P.spanStart) declLocation,
      ":decl_end_col" := (P.sourcePosColumn . P.spanEnd) declLocation,
      ":decl_end_line" := (P.sourcePosLine . P.spanEnd) declLocation,
      ":decl_comments" := encode comments,
      ":ann" := serialise ann,
      ":decl" := serialise decl
    ]
  where
    ann = _idaAnnotation declAnn
    annLocation = _annLocation ann

    decl = _idaDeclaration declAnn

    (declLocation, comments) =
      decl
        & declSourceType
        & maybe P.nullSourceAnn P.getAnnForType

declSourceType :: IdeDeclaration -> Maybe P.SourceType
declSourceType = \case
  IdeDeclValue x -> Just (x ^. ideValueType)
  IdeDeclType x -> Just (x ^. ideTypeKind)
  IdeDeclTypeSynonym x -> Just (x ^. ideSynonymKind)
  IdeDeclDataConstructor x -> Just (x ^. ideDtorType)
  IdeDeclTypeClass x -> Just (x ^. ideTCKind)
  IdeDeclValueOperator x -> x ^. ideValueOpType
  IdeDeclTypeOperator x -> x ^. ideTypeOpKind
  IdeDeclModule _ -> Nothing

resolveLocations :: (MonadIO m, MonadReader LspEnvironment m) => [IdeDeclarationAnn] -> m [IdeDeclarationAnn]
resolveLocations = traverse resolveLocation

resolveLocation :: (MonadIO m, MonadReader LspEnvironment m) => IdeDeclarationAnn -> m IdeDeclarationAnn
resolveLocation (IdeDeclarationAnn ann d) =
  convertDeclaration'
    annotateFunction
    annotateValue
    annotateDataConstructor
    annotateType
    annotateType -- type classes live in the type namespace
    annotateModule
    d
  where
    -- annotateFunction :: _
    annotateFunction x d' = do
      def <- selectIdentSourceSpan IdeNSValue $ P.runIdent x
      type' <- selectIdentSourceType x
      pure $
        IdeDeclarationAnn
          ( ann
              { _annLocation = def,
                _annTypeAnnotation = type'
              }
          )
          d'
    annotateValue x d' = do
      def <- selectIdentSourceSpan IdeNSValue x
      pure $ IdeDeclarationAnn (ann {_annLocation = def}) d'
    annotateDataConstructor x d' = do
      def <- selectIdentSourceSpan IdeNSValue x
      pure $ IdeDeclarationAnn (ann {_annLocation = def}) d'
    annotateType x d' = do
      def <- selectIdentSourceSpan IdeNSType x
      pure $ IdeDeclarationAnn (ann {_annLocation = def}) d'
    annotateModule x d' = do
      def <- selectIdentSourceSpan IdeNSModule x
      pure $ IdeDeclarationAnn (ann {_annLocation = def}) d'

insertIdentSourceSpan :: (MonadIO m, MonadReader LspEnvironment m) => IdeNamespace -> Text -> P.SourceSpan -> m ()
insertIdentSourceSpan nameSpace ident span =
  DB.executeNamed
    (Query "INSERT INTO ident_source_spans (ident, start_col, start_line, end_col, end_line) VALUES (:ident, :start_col, :start_line, :end_col, :end_line :name_space)")
    [ ":ident" := ident,
      ":start_col" := P.sourcePosColumn (P.spanStart span),
      ":start_line" := P.sourcePosLine (P.spanStart span),
      ":end_col" := P.sourcePosColumn (P.spanEnd span),
      ":end_line" := P.sourcePosLine (P.spanEnd span),
      ":name_space" := serialise nameSpace
    ]

selectIdentSourceSpan :: (MonadIO m, MonadReader LspEnvironment m) => IdeNamespace -> Text -> m (Maybe P.SourceSpan)
selectIdentSourceSpan name_space ident =
  fmap toSpan . head
    <$> DB.queryNamed
      (Query "SELECT start_col, start_line, end_col, end_line FROM ident_source_spans WHERE ident = :ident and name_space = :name_space")
      [ ":ident" := ident,
        ":name_space" := serialise name_space
      ]
  where
    toSpan :: (Int, Int, Int, Int) -> P.SourceSpan
    toSpan (startCol, startLine, endCol, endLine) =
      P.SourceSpan
        (T.unpack ident)
        (P.SourcePos startLine startCol)
        (P.SourcePos endLine endCol)

insertIdentSourceType :: (MonadIO m, MonadReader LspEnvironment m) => P.Ident -> P.SourceType -> m ()
insertIdentSourceType ident ty =
  DB.executeNamed
    (Query "INSERT INTO ident_source_types (ident, type) VALUES (:ident, :type)")
    [":ident" := P.runIdent ident, ":type" := serialise ty]

selectIdentSourceType :: (MonadIO m, MonadReader LspEnvironment m) => P.Ident -> m (Maybe P.SourceType)
selectIdentSourceType ident =
  fmap (deserialise . fromOnly) . head
    <$> DB.queryNamed
      (Query "SELECT type FROM ident_source_types WHERE ident = :ident")
      [":ident" := P.runIdent ident]